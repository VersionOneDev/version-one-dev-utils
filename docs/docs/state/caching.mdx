---
sidebar_position: 7
---

# Caching

Caching can be used to optimise duplicate calls to actions allowing components to request the state they require independently.
When an action is cached **any subsequent calls with matching props will return the cached payload** rather than running the action again.

## Configuration

Each store manages it's own cache and a `cache` object with the following properties can be passed to the `createStore` function for configuration:

| Property | Value                                                                                                                  | Default          |
| -------- | ---------------------------------------------------------------------------------------------------------------------- | ---------------- |
| lifespan | The length of time(ms) actions should remain in the cache. A value of **-1** can be used to permanently cache actions. | 3600000 (1 hour) |

Example:

```javascript
import { createStore } from "version-one-dev-utils/state";

export const CounterStore = createStore({
  name: "CounterStore",
  initialState: {
    count: 0,
  },
  /** Cache actions for 1 minute */
  cache: { lifespan: 60000 },
});
```

:::note Lifespan and expiry
Actions that have exceeded their lifespan will be removed then cached again the next time they are called.
**A lifespan of `-1` can be used to prevent a cached action from expiring and being removed.**
This is useful for callback actions that should continue to update state indefinitely for example when connecting to a WebSocket.
:::

## Adding actions to the cache

Actions can be added to the cache by passing a `cache` value to the options of the `createSyncAction`,
`createAsyncAction`, and `createCallbackAction` helper functions.

```javascript
import { createAsyncAction } from "version-one-dev-utils/state";
import PropTypes from "prop-types";

const add = createAsyncAction((props) => Promise.resolve(props.value), {
  propTypes: {
    value: PropTypes.number.isRequired,
  },
  /** Cache the action */
  cache: true,
});
```

#### Setting the lifespan of individual actions

An object with a `lifespan` property can be used instead of a boolean to control the lifespan of the individual action:

```javascript
import { createAsyncAction } from "version-one-dev-utils/state";
import PropTypes from "prop-types";

const add = createAsyncAction((props) => Promise.resolve(props.value), {
  propTypes: {
    value: PropTypes.number.isRequired,
  },
  /** Cache the action with a lifespan of 30 secs */
  cache: { lifespan: 30000 },
});
```

## Accessing the cache API from a store

The cache API allows for manual control over the cache and is exposed by each store using `StoreName.cache`.

### Setting the payload of an action in the cache

An action can be manually cached (without the action itself being called) by calling the `StoreName.cache.update` function, passing the action `type`, `props` and a new `payload`.
An optional configuration object can be passed to control it's lifespan.
If an action with matching type and props is already in the cache it will be overridden.

```javascript
StoreName.cache.set(
  "add",
  { value: "1" },
  { value: "new value" },
  /** Optional **/
  { lifespan: 30000 }
);
```

### Removing an action from the cache

An action can be removed from the cache by calling the `StoreName.cache.remove` function and passing the action `type` and `props`.
If an action with matching type and props has been cached it will be removed.
The action will be cached again the next time it is called.

```javascript
StoreName.cache.remove("add", { value: "1" });
```

### Removing all actions from cache

The entire store cache can be cleared by calling the `removeAll` function.
Actions will be cached again the next time they are called.

```javascript
StoreName.cache.removeAll();
```
